# 指令与组件概述

## 指令归来

我们前面提到过：早在Angular 1的时代，指令就已经被细分成了三种，到了Angular 2中，它们被正式命名为：组件、属性型指令、结构型指令。

### 组件

在Angular 1中，有一类指令的用途是把控制器和模板关联在一起的，被称为“组件型指令”。在Angular 2中，它正式被命名为“组件”。用最简单的说法，组件就是有模板的指令。组件通常是Angular 2应用中出现最多的构造块儿，几乎所有可见的部分都是大大小小的组件，这些组件可以相互嵌套，可以相互协作，共同构成丰富多彩的可见视图。

在代码层面，组件其实就是一个普通的类，唯一的不同是它增加了一个`@Component()`装饰器。这个装饰器起什么作用呢？它提供的是组件的元数据`ComponentMetaData`。要想成为组件，一个类必须得提供一些额外的信息才行，比如它关联到的模板，这些信息就是来自元数据。正如“元数据”这个名字所揭示的，它不是代码，也基本不会被自己的代码使用，它是给框架用的。Angular 2发现某个类有元数据，就会根据这些元数据把这个类注册成组件类。

在`ComponentMetaData`中有几个属性值得注意：

- `template`或`templateUrl`：像Angular 1中一样，它提供模板内容或模板地址。
- `selector`：像Angular 1中的指令名一样，它提供一个CSS/jQuery选择器。当Angular视图渲染页面时，就会对各个已知组件的选择器进行匹配，那个组件能匹配上就把这个元素(被称为宿主`host`元素)的控制权交给这个它，让它为所欲为。
- `styles`或`styleUrls`：指定组件的样式或样式表地址。如果视图包装模式`encapsulation`被设置为原生或仿真，那么这里定义的样式就只会对当前组件生效，而不会泄漏到上级或下级。
- `directives`：组件中使用到的自定义或第三方指令(含组件)数组。与Angular 1中不同，要想使用指令，必须得在使用者的元数据中进行注册，否则就不会生效。Angular 2内建的指令不用注册，是因为它们已经自动进行了预注册。这是初学者比较容易遇到的一个坑，需要留意。
- `pipes`: 组件中使用到的自定义管道(过滤器)数组。管道是过滤器在Angular 2中的对应物，但它同样需要在使用者的元数据中进行注册，否则就不会生效。

为什么指令和管道在Angular 2中都开始要求注册了？因为Angular 2撤销了Angular 1中的“模块”概念，因此如果让指令或管道成为全局的，那么当同时存在多个同名指令或管道时，将无法决定使用哪一个，而通过注册的方式，我们可以随意指定使用哪一个，甚至在这个组件中使用C1组件，而在另一个组件中使用与之同名的C2组件。

除此之外还有一些属性，如`inputs`(输入参数表)、`outputs`(输出参数表)、`queries`、`encapsulation`(视图包装模式)等。这里就不展开了，读者可以自己到官方文档中查看。

### 属性型指令

在Angular 1的社区文章和早期版本的Angular 2中，有一种指令叫装饰器(Decorator)型指令。它的作用是对现有的DOM元素或组件型指令进行修饰，比如修改外观或为其增加某些特定的行为等。它在Angular 2中的正式名字是属性(Attribute)型指令，因为它习惯上都是作为元素的属性来使用的。如`<input my-highlight />`。

与组件不同，属性型指令使用`@Directive()`装饰器，它提供的元数据是`DirectiveMetaData`类型的。事实上，虽然没有明确的继承关系，但`ComponentMetaData`可以看做`DirectiveMetaData`的一个子类 —— 正如组件在概念上是指令的一个子类一样。

在Angular 1的应用中，曾经需要很多小型的属性型指令，如挂接`touch`系列事件等，不过现在你可以把它们删掉了。前面提到过，Angular 2的数据绑定机制有了一个巨大的提升，你可以直接使用绑定来代替这些小型的属性型指令。

在Angular 2的官方文档中，曾经用一个“组件事件日志”的属性型指令来跟踪组件的生命周期(下一节详述)，这就是一个比较典型的场景。

通常属性型指令都用来完成一些小型的或AOP的任务。请保持简单和中立，以免毁了你代码的可读性。关于属性型指令的另一项忠告是：想清楚，只有当确实需要用时才用它。

### 结构型指令

无论是组件还是属性型指令，都是不会修改现有的DOM结构的(组件在概念层也不会修改，因为它只是创建了一个概念上的Shadow DOM)，但我们确实需要删除/添加DOM节点或者把一个节点重复很多次。要完成这个任务，我们在Angular 1中用`ng-if`、`ng-repeat`或在Angular 2中用`ngIf`、`ngFor`等。这些指令被称为“结构型指令”。

结构型指令也使用`@Directive()`装饰器。装饰器的元数据与属性型指令的一样，主要的区别是它会依赖`queries`属性，借助这个哈希属性，可以查询到当前指令所包含的子节点，并且据此调整DOM结构，比如删除它或者把它重复渲染N份。

在使用上，结构型指令通常会用语法糖形式，也就是`*ngIf`，它会被Angular展开语法糖(下一节详述)然后生效。

在Angular 1中，自己要实现结构型指令还是比较麻烦的，而在Angular 2中，借助元数据和语法糖的支持，实现结构型指令就简单多了，比如在官方文档中，就自定义了一个`myUnless`结构型指令，包含辅助语句在内只用了20行代码。

不过，虽然Angular 2给了你一个强有力的锤子，也千万别用它敲打全世界。如果能用内建指令或内建指令的组合来实现，那就不要写不必要的自定义指令。这对于项目的统一性，减少上手难度是非常必要的。

对于Angular 2的指令，需要特别注意的一点是它不再具有指令优先级的概念，因此不能再像Angular 1中那样把`ng-if`和`ng-repeat`写在同一个节点上，靠优先级来保证先后顺序，而应该把`ngIf`嵌套在`ngFor`内部，借助DOM节点的自然顺序来实现优先级。这个改动除了简化概念、避免误用以外，还与结构型指令的语法糖展开原理有关。

## 组件与WebComponents

我们说，Angular 2是以组件为中心的，这意味着在实际的应用开发中，组件将会是你接触得最多的东西。可以说，用好了组件，你才迈进了Angular 2的门槛。

Angular 2中的组件是对将来WebComponents标准的提前实现。WebComponents目前尚未成为正式标准（而且标准化进度也不理想），因此还没有什么标准答案。我们只针对MDN上所说的四个要点进行讨论。

### 自定义元素(Custom Elements)

其实我们在Angular 1中就已经用过了大量的自定义元素。比如：当我们使用一个自定义指令`<my-elem></my-elem>`时，其实就是在使用自定义元素。不过，在WebComponents标准中，自定义元素还具有更多的要求，比如支持元素的生命周期。在Angular 1中，对元素的生命周期只提供了非常有限的支持（不过1.5版已经引入了生命周期钩子），而且书写不便；而Angular 2提供了更加完善的生命周期支持，那就是“生命周期钩子(Lifecycle Hooks)”。

这些生命周期钩子包括：

- ngOnChanges：属性发生了变化时触发（包括设置初始属性）
- ngOnInit：组件中所有绑定的属性已经初始化完毕时触发
- ngDoCheck：对属性进行变更检测时触发，可以自定义变更检测逻辑
- ngAfterContentInit：(仅适用于组件)外来内容投影进来之后触发（可以先不要管“投影”这个词，先看成子视图即可，后面我会再专门讲它）
- ngAfterContentChecked：(仅适用于组件)检查完投影内容的所有数据绑定之后触发
- ngAfterViewInit：(仅适用于组件)创建完组件的视图之后触发
- ngAfterViewChecked：(仅适用于组件)检查完组件视图的所有数据绑定之后触发
- ngOnDestroy：组件即将被销毁时触发，在这里可以释放资源，如解除事件监听、停止定时器等

可见，Angular 2对生命周期的支持已经非常完善了。借助生命周期，我们才能对自定义元素进行更加精准的控制，使其成为一项更加强力的技术。

### HTML模板(HTML Templates)

虽然有些人声称“命令式UI”优于“声明式UI”，但实际上典型的声明式UI —— HTML模板才是未来的标准。我们来看看HTML模板在WebComponents中的应用。在WebComponents中，为模板专门定义了一个HTML元素`template`，它默认具有`display: none`样式，换句话说，它默认是不可见的。

虽然我们在寻常的Angular 2代码中看不到这个元素，但实际上它是“结构型指令”的核心机制。所谓“结构型指令”是从Angular 1中细分出来的三大指令类别之一，比如`ngIf`、`ngFor`等都是结构型指令，它们的核心特征是会动态改变DOM树的结构，而组件和属性型指令通常不会如此。

那么，`template`在哪里？实际上，我们常用的写法`*ngIf`本身并不是指令而是语法糖，`ngIf`才是指令，比如：

    <p *ngIf="condition">
      Our heroes are true!
    </p>

等价于

    <template [ngIf]="condition">
      <p>
        Our heroes are true!
      </p>
    </template>

解开语法糖之后，默默藏在幕后的`template`元素终于亮相了。其它结构型指令也是如此。

除了结构型指令之外，模板也是组件型指令的重要组成部分。通过使用模板，Angular 2分离了两个主要的关注点：模型和视图，使其可以相对独立的演化，甚至可以由不同的人来维护，复用的成本也较低。唯一的缺点是它相对于命令式UI在理论上会慢一点，但是正如普通人类无法感受到10毫秒和100毫秒的差异一样，这种理论上的缺点远不如实用性上的优点更有价值。

### 影子DOM(Shadow DOM)

在Chrome中，如果你在开发者工具中打开了“Show user agent shadow DOM”选项，就会看到诸如输入框、播放器之类的元素不再是一个单纯的元素，它里面包含了一个`#shadow-root`子节点，这就是Shadow DOM —— 藏在暗影世界中的实际控制者。

Shadow DOM是WebComponents中的重要组成部分。在实践中，你可以把它看做一个超轻量级的iframe，暗影世界与外面的光明世界被隔绝开，只剩下有限的几种通讯方式。没错，这就是“封装”，现在，它被用到了DOM体系中。这种抽象与封装的能力，正是WebComponents借以问鼎未来标准的关键所在。

这里的问题在于，只有Chrome和Opera才实现了Shadow DOM，在其它浏览器中都是不可用的。因此，Angular 2只借助Shadow DOM的概念实现了少量特性，并提供了原生和仿真两种实现方式，以兼容不同的浏览器。在Angular 2中，这个特性就是“组件样式(Component Styles)”。

所谓“组件样式”，就是Shadow DOM中的一个特性：样式隔离。简单说就是：外部（光明世界）的样式不会影响到内部（暗影世界），内部样式也不会泄露到外面来。这其实就是最近方兴未艾的CSS模块化思想。如果使用浏览器的原生Shadow DOM支持，它很容易实现；但是如果使用仿真模式，就只能自己对CSS进行处理了。

Angular 2中通过组件元数据中的`styles`和`styleUrls`数组来指定“组件样式”。当使用仿真模式(默认值)时，Angular会对其进行处理，使得每一个样式都精确限制于自身，而不会随意泄露到父组件或子组件中。除此之外，它还支持与Shadow DOM有关的一些增强选择器`:host`、`:host-context`等，以便组件能自行根据所在的环境呈现出不同的外观。当然，目前在原生模式和仿真模式下还有一些细微的差异，还不清楚官方是否会在发布前解决。不过无论如何，在目前的情况下，仿真模式几乎是工程化应用中唯一的选择了，不用太纠结于这点差异。

### HTML导入(HTML Imports)

HTML导入几乎完全是对浏览器的要求，在Angular 2中目前没发现与HTML导入类似的技术。纯粹从概念上来说，组件之间的相互导入以及组件的指令依赖`directives`勉强可以算和HTML导入沾边了。

