# 依赖注入简介

简单来说，依赖注入是一种降低代码之间的耦合度，提高代码的灵活性的编程方法。事情是这样子的：

我们编程都是从`Hello World`开始，但它不会永远停留在`Hello World`，它会变得越来越复杂。为了能够掌控程序的复杂，我们引进了模块化。模块化的目的是切分复杂，带来的问题是需要考虑代码之间的合作问题（不只是多人之间的代码，还有自己写的代码之间的合作问题）。合作意味着依赖，比如模块A依赖模块B提供的功能。具体到面向对象编程就是对象A里面，需要使用到对象B的实例。

现在问题来了，对象B的实例化是在对象A里面实例化呢，还是先实例化，再将实例化后的实例当参数传给对象A呢？如果实例化的方式不变，当然在对象A里面实例化最好了，因为使用对象A的程序员不需要关注对象A还依赖了对象B。可是呢，需求总是在变化。如果哪天对象B改变了，它在实例化的时候要求添加一个参数，这下对象A就傻了。因为需要将对象B实例化的代码做更改，这相当于A限制了B的改变（不能只修改B，还要考虑到A）。

那就选择将对象B的实例当参数传给对象A吧（解决问题的一种方法），这样对象A就不需要知道对象B是如何实例化的了（**题外话，对象B依然需要保证提供的服务方式不变或者说暴露的接口不变**）。这种将依赖的引入从使用者的代码中分离出来，交由框架管理的技术叫做**控制反转**（Inversion of Control）。OK，这里有两种方式将对象B的实例传给对象A。一种是对象A先声明依赖了哪些对象，框架根据声明去实例化这些对象并传给A。另外一种是对象A在需要的时候自己去问框架，框架返回A所依赖的对象B的实例。

这两种方式都是**把对象的实例化的问题交由一个依赖管理框架**。第一种方式叫**依赖注入**（Dependency Injection），第二种方式叫**依赖查找**（Dependency Lookup）。这两者的区别在于框架把依赖注入给对象，还是对象主动查找需要的依赖。

不管用没用控制反转，代码需要做的事情是一样都不少，控制反转只是将这种实例化的工作交给了代码而不是开发者。因为交给了代码来做，与代码的交互只能变得固定了（比如声明依赖的方式）。**使用控制反转的好处是对象B的修改升级只需考虑对象B和依赖框架**。

## 参考文章

1. 依赖注入（[https://github.com/android-cn/blog/tree/master/java/dependency-injection](https://github.com/android-cn/blog/tree/master/java/dependency-injection)）
2. 控制反转（[https://zh.wikipedia.org/wiki/控制反转](https://zh.wikipedia.org/wiki/控制反转)）
