# 漫漫升级路……竟然这么简单？

![捷径](./_images/level-up.svg)

按照SemVer的标准，主版本号之间并不需要兼容。然而即便如此，人们仍然会期待有一条从前一个版本升级到后一个版本的明确路径。

Angular开发组提供了这条升级路径。

根据git记录，Angular开发组从2015年10月就已经提供了`UpgradeAdapter`类，而[相关文档](https://www.angular.io/docs/ts/latest/guide/upgrade.html)也早在2015年11月就写完了第一版。

当然，官方开发组的重点还是在研发上，没有对这些进行宣传，不关注Angular的人不了解它也在情理之中。不过，随着Angular开发工作的逐步收尾，宣传工作重新回到前台，相信我们会不断看到关于它的消息。

本文就将带你了解一下Angular开发组提供的完整升级方案。

## 做更好的自己

即使你尚未决定或者不需要对Angular 1程序进行升级，也应该看看这一节。因为本节不讲升级，而是讲对Angular 1程序做重构和优化。这就意味着，无论你是否对Angular 2感兴趣，都应该好好看看它。就像王自健说的：“就算你泡不到健身教练，至少也能落一好身体嘛”。

### 遵循最佳实践

好代码都是一样的，烂代码却各有各的烂法。

由于Angular 1的历史遗留问题，很长时间内都没有一个众所周知的官方或半官方“风格指南”。不过幸运或不幸的是，等到Angular 2开始开发之后，终于出现了一个被官方认可的Angular 1“风格指南”，参见[这里](https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md)。虽然晚，但毕竟有了。

这份“风格指南”中的每一条都值得好好遵循或理解，不过其中对升级影响最大的是三条：

1. 每个文件中只放一个程序部件，比如控制器、服务、指令等都应该各自占用一个独立的文件，而不应该跟别的文件合并在一起。
1. 按特性组织目录。实现同一个特性的相关文件都应该放在同一个目录下，比如一个组件的`.html`、`.js`、`.css`、`.spec.js`文件都应该用同一个基本名放在同一个目录下，而不应该放在相隔很远的地方。
1. 模块化。应该使用模块化的写法，而不要写游离在模块外的代码，比如你虽然也可以用一个全局函数来实现控制器，但是你还是应该把它注册到`angular.module`中。模块化的写法可以彻底告别全局变量，而且迁移到Angular 2也容易得多。

可见，无论是否准备升级到Angular 2，遵循这些要求都会给你带来好处。

如果你是我们那本儿《AngularJS深度剖析与最佳实践》的读者，那么恭喜你，这三条规则在我们的书中都被严格遵循着，有些还做了解说。按照我们的建议写的程序会更容易升级一些。

### 改写成npm+module loader结构

要实现模块化，还需要使用模块加载器，比如Webpack。如果你仍然使用传统写法，那么建议先按照前面的最佳实践重构完代码之后再开始迁移到模块加载器。Webpack是一个广受欢迎的模块加载器，有很多激动人心的特性，感兴趣的同学可以在网上搜索资料来学习它。这是一个公共技能，与具体的前端框架无关，学了是不会浪费的。

要把传统的写法改写成用模块加载器的，是一项略显枯燥的工作，不过好处是它将给未来的进一步开发工作打下坚实的基础。如果你当初创建项目时使用的就是Webpack或Browserify等模块加载器，那这一步就简单多了。如果你正在用Angular 1.2，可以顺手把它升级到最新的1.5版，在这几个次版本之间没有引入破坏性变更，所以你的代码只要没有使用过依赖底层实现的hack技巧，那就应该不会被破坏。

### 加测试

任何一个大型变更，都需要测试的保障。如果项目较大，那么显然仅靠人工测试是不够的。如果你以前没有为项目写过自动化测试，那么现在正是一个添加它的好时机。

自动化测试分成两个层面：一个是来自用户视角的端到端(E2E)测试，它用来模拟最终用户的操作行为并检查页面输出结果；另一个是来自开发视角的单元测试，它用来对代码的接口及其实现提供保障。

第一优先级要实现的是端到端测试，它的成本相对较低，而且有很多专业的测试人员本来就会写端到端测试。要小心的是，不要在端到端测试中依赖与Angular 1有关的特性。比如，不要根据Angular 1的属性型指令定位任何元素，否则等将来迁移到Angular 2的时候它们将会被破坏。如果你使用的是Protractor，那么就不要使用那些与Angular 1有关的定位器，除非其它定位器写起来太繁琐。

如果你幸运的处于一个代码公有制的团队中，那还有一种更好的方法来简化端到端测试的书写方式：把id作为主要定位器。在风格良好的Angular程序中，基本不会出现需要用id的情况（除了label-input元素对），那么，我们就可以把id完全留给测试人员，程序员自己不得不用id的时候加上特殊的前缀，免得和测试人员写的id冲突了。这样，测试人员需要定位哪个元素，随意给它加上有业务含义的id就好了。这样不管以后会如何变化，你的测试都不会被破坏。

然后，你就可以根据需要添加一些单元测试了。当然，你不用等所有单元测试都写完再开始向Angular 2升级，边升级边写单元测试是更好的方案。不过如果在开始向Angular 2升级之前有一段儿空档期，反正闲着也是闲着，不妨先补一点单元测试，反正早晚也要做。

### 改写成TypeScript

很多人一听到“强类型”三个字就想到了Java的繁琐与约束，并本能的拒绝。但TypeScript不同，它的强类型是可选强类型。事实上，TypeScript语法是ES6的一个超集（也间接是ES5的超集），这就意味着ES6/ES5的源码可以直接当做TypeScript编译。如果你觉得ES6不是束缚，那么TypeScript也不是。

所以，改写成TypeScript的第一步就是 —— 改扩展名。没错，因为它完全向后兼容，改完之后这步儿就算初步完成了。你可以让它上线运行了。

在这之后，可以首先把主要接口函数的参数加上类型。TypeScript的类型定义非常灵活，比如它可以让你指定这个参数可以是`string` **或** `Date`类型而不能是其它类型；你可以要求这个哈希参数中至少要有一个叫`name`的属性和一个叫`hello`的方法等等。加类型注解并不会对Angular 1程序的执行产生任何影响，它只是给IDE和TypeScript编译器看的。所以，只要不犯低级错误，你甚至可以不需要测试就能保证自己所做的修改不会破坏程序的原有功能。

加上类型之后，你可以把原来的某些`function`改写成`class`的形式，以使用更加现代化的语法。对于转型过来的后端开发人员，这样也会进入一个更熟悉的世界。这一步对代码的改动通常会比较大，如果以前没有单元测试，最好补上之后再开始改。

### 切分成MSPA架构

我们常规的前端程序被称为SPA(单页面应用)，而MSPA就是多个(Multi-)单页面应用。当一个前端程序成长到一定程度，我们就得想方设法把它拆小了，最简洁明了的方式就是把程序拆分成多个子项目，每个子项目独立部署，然后……重点来了！然后让子项目之间通过URL互相链接起来。这样，每个子项目完成一个相对完整的功能，自己完成不了的就通过URL跳转到其它子应用中去，必要时还可以通过URL传递一些参数。比如在一个商城中：产品列表、购物流程、个人中心都可以拆分成独立的子项目。

这种方式有一个明显的优点，那就是很容易控制每个子项目的规模，当然，在一般的团队中，这都会需要一个好的架构师来负责拆分和掌控。作为Angular 1应用的改进，这种方式可以有效地控制单个项目的大小，减少内存占用，并防止代码无意中产生“跨界”影响、散播BUG。作为升级前的准备工作，它的优点更加明显：你可以按子项目为单位从易到难、从周边到核心进行升级，这样项目进行得会很顺利，风险也更小。因为子项目之间不关心彼此的实现细节，所以这也同时得到了一个松耦合架构。

如果你的升级需求并不紧迫，那么建议你先在自己熟悉的Angular 1领域中完成拆分，然后再开始向Angular 2升级。这样，你的升级风险就会得到更有效地控制，而且也有利于分成多个团队并行工作。

## 不知不觉，就变了

一旦完成了上面这些步骤，就可以开始我们的升级之旅了！

Angular 2升级方案的精髓在于平滑迁移，你可以一边迁移、一边改BUG、一边添加新功能，业务部门并不需要知道你在迁移代码。

要制定并实现这样的升级方案确实需要付出不少努力，不过，在高度工程化的团队中，这也算不上什么黑科技。而Angular开发组，恰恰是以高度工程化而见长的。请跟我来，看看这个Angular开发组花了半年多才完成的升级方案是怎样的。

### 导演登场:升级适配器

在升级过程中，Angular 1和Angular 2是长期共存的。但Angular 1和Angular 2各自有着自己的技术体系，想让它们共存就需要有一座桥梁，这座桥梁既要“懂”Angular 1，也要“懂”Angular 2。它就是`UpgradeAdapter`类！它随着Angular 2一起发布，位于`upgrade`模块中，通常并不会被标准的Angular 2程序用到。要想使用它，我们就得自己`import`它。它是整个升级过程中的总导演，我们后面的很多步骤都会用到。

### 变成Hybrid应用

所谓Hybrid，直译就是“混血儿” —— 对，它就是星际二中的反派军队“混合体”，同时它还是Cordova等移动开发方案的统称。这两者，呃，三者，显然不是同一个概念，不过它们都可以用Hybrid命名：Angular 1和Angular 2两项技术融合在一起、星灵与异虫融合在一起、Native程序与H5程序融合在一起。不同的是，其它的混合体都是结果，而这里的混合体只会在向Angular 2升级的过程中存在，等到升级完它就完全消失了 —— 它是一个只在升级时用到的“拐杖”。

我们需要先改写Angular 1应用的引导方式。Angular 1中支持两种主要的引导方式，一种是`ng-app`指令，一种是手动调用`bootstrap`方法。在Angular 2中和`UpgradeAdapter`中，已经不存在`ng-app`指令了，所以只能使用后一种方式。不过幸运的是，`UpgradeAdapter`所提供的`bootstrap`方法与Angular 1中的完全相同。所以，我们只要去掉`ng-app`指令，同时在应用的启动代码中调用`UpgradeAdapter`的`bootstrap`方法来引导应用就可以了。这样一来，我们的应用就直接变成了Angular 1和Angular 2混血的Hybrid应用，你既能写Angular 1代码，也能写Angular 2代码，而且这两个框架都是全功能的而不是裁剪过的版本。

### 悄悄的，把演员一个个换掉

接下来，最重要的一步儿开始了。我们需要一个文件一个文件的把它们升级，这也是整个开发过程中最费时间的部分了。不过，再强调一次：先遵循最佳实践改造原有的Angular 1程序，然后再开始真正的升级工作，把这两件事混在一起做会导致高风险以及低效率。

Angular 1的很多概念和Angular 2中的不同，不过它们仍然存在很多内在联系。接下来，我就带你看看这些主要的变化以及对应的升级策略。

#### 模块：没用了，删掉吧

在Angular 1中，`angular.module`是用来把传统的ES5代码组织成模块的，而Angular 2中已经使用了CommonJS等标准模块加载机制。所以，如果需要把在模块中定义的程序部件迁移到Angular 2，只要简单的忽略模块就行了。在Angular 2中把它暴露出来之后，原来的Angular 1代码仍然可以通过互操作机制来调用它。所以，可以挨个把代码从Angular 1模块中搬出来，搬空了之后把模块删掉就万事大吉了。

#### 改写控制器

在Angular 1中，控制器主要用在路由中和一部分指令中。无论写在哪里，它们的功能其实都是类似的 - 初始化VM。在Angular 1.3之后，通过`controllerAs`和`bindToController`等新语法，控制器的功能实际上已经和VM合二为一了。

所以，在Angular 2中，干脆已经不存在控制器的概念了，它们的职责被隐藏到了框架的内部实现中。换句话说，Angular 2不再是`MV*`框架，而是变成了实实在在的`MVVM`框架。体现在代码上，就是Angular 1中的控制器被改写成了一个`ViewModel`类。所有导出给模板中使用的属性和方法，不需要再赋值给`Scope`实例，而是直接成为了`ViewModel`的成员属性和成员方法。如果你已经在广泛使用1.3中引入的`controllerAs`和`bindToController`语法了，那么这个迁移过程将会变得非常简单。

#### 细分指令

在Angular 1的时代，指令曾是一个筐，其中装了很多截然不同的东西。在国外的很多文章以及我们那本《AngularJS深度剖析与最佳实践》中，都对指令进行了细分，最明显的两种是元素型指令(组件)和装饰器型指令(属性型指令)，还有一种是在Angular 1中很少自己写的“结构型指令”。

元素型指令的作用和传统的路由页面差不多，它同时具有控制器(VM)和模板，在它的代码中，不需要访问任何DOM元素，而是构建模型，等待模板来使用它。外在表现上，它通常作为元素使用，比如`<user-list>`，并且它的大多数逻辑会写在控制器中，而不是`link`函数。即使沿用传统习惯写在了`link`函数中，它也不会去访问`element`变量。在Angular 2中，它终于得到了正式的名分，很干脆，就叫“组件”，当然，在底层实现上，它仍然是“指令”的一种。它使用`@Component`装饰器。

装饰器型指令则用于对现有元素(包括原生元素和组件)进行装饰 —— 修改属性、挂接事件等。因为这个特殊的定位，它本身通常不需要带自己的模板，但它会操纵宿主的DOM元素。外在表现上，它通常作为属性使用，比如`<input ng-click="doSomeThing()" />`，它的逻辑通常会写在`link`函数中，但是，这种指令应该保持尽可能的精简，要记住自己的角色是且仅是View和Model之间的桥梁。如果你有过于复杂的装饰器型指令，就要认真考虑先重构成一个组件加一个或几个小型装饰器指令了，否则在迁移过程中你可能会吃尽苦头。在Angular 2中，它获得了正式的名称，叫做“属性(Attribute)型指令”。它使用`@Directive`装饰器。

结构型指令在Angular 1中就是`ng-if`、`ng-repeat`这类内置指令，我们很少会自己写，教程中一般也很少教怎么写。我曾经参考Angular 1的源码自己写过一个，但不好看。在Angular 2中，提供了一种写结构型指令的优雅方式。不过，由于Angular 1中很少有这种指令，也就不专门讲它了。它也使用`@Directive`装饰器。

#### 换内建指令

在Angular 1的模板中使用了很多Angular 1特有的指令，我们需要把它们替换成对应的Angular 2指令。Angular 1中的很多指令在Angular 2中已经不存在了，这种情况多数是因为Angular 2中不需要它们了，请把它们换成属性绑定或事件绑定。另外一些指令，如`ng-class`，在Angular 2中有了名字和功能几乎相同的属性型指令，请按照文档替换它们。还有一些指令，如`ng-repeat`在Angular 2中被替换成了`ngFor`，请按照文档手工替换它们。这些都是比较繁琐的工作，不过只要照文档做，遇到问题就解决，通常也不会遇到很明显的坑。

#### 换过滤器

在Angular 1中，过滤器扮演着很重要的角色。它的使用格式是：变量后面跟着一个管道符号(|)再跟着过滤器的名称。咦？管道符号后面直接叫管道就好了嘛，为什么叫过滤器？恭喜你，答对了！Angular开发组也是这么想的。于是，过滤器摇身一变，在Angular 2中改名成了“管道”。原有的大多数内建过滤器也都有了对应的管道，名字也基本没变。

不过，有两个过滤器消失了：`filter`和`orderBy`，这是因为Angular 2更加注重“变更检测”速度，而这两个过滤器对它影响比较明显，于是……这两个过滤器不再提供内建版本，而是让程序员自己在组件中或Model层实现相关的逻辑。当然，你也可以找一个社区提供的管道版本，不过，就个人经验来说，还是自己在组件或服务中实现比较靠谱，把它放在View层容易导致分层不清晰，对长远维护来讲是不利的。

还有一个过滤器要小心点儿，那就是`limitTo`过滤器，它被替换成了`slice`管道，不过**它的参数顺序变了**！要千万小心，不能一替了之。

#### 改写服务注册代码

在Angular 1中，所有服务都被注册进了`module`中，并据此来管理相互依赖。在Angular 2中，这种服务依赖被明显细化了，不再是模块之间的依赖，而是按组件组织成的依赖树。这个话题比较大，我们只要先知道Angular 2中的服务与依赖管理已经从模块级细化到了组件级就行了，将来会有专门的文章来详细阐述这一点。

#### 重写路由

由于控制器被组件所取代，Angular 2中的路由机制也相应发生了重大变化。Angular 2中的路由机制可谓一波三折，由于原来的路由库作者和其它成员意见不合，愤而出走，所以开发组不得不重写了路由库，目前仍然未发布最终版。不过幸运的是，从代码上看，其对外接口的变化并不大，所以现在即使先沿用已经废弃的Angular 2组件路由，将来应该也不需要做大修。当然，所有这些，都是可以Angular 1和Angular 2的版本并存的，你尚未升级的那部分代码，仍然可以完全沿用以前的写法。

#### 去掉$apply

Angular 2完全重写了“变更检测”机制，在显著提高性能的同时，还简化了使用方式。最显著的变化是不再需要`$apply()`方法，一切检测都变成了自动的，完全交给Angular自己管理。即使正在升级的Hybrid程序中的Angular 1代码，实际上也不需要再调用它了，但调用它也不会导致任何错误，它只是简单的忽略这个方法，以保证向后兼容。所以，在升级过程中顺手删掉它就可以了，不用担心产生什么负面影响。

### 无处不互通

再强调一遍，在Hybrid程序中，任何Angular 1的程序部件和任何Angular 2的程序部件之间都是互通的：

- Angular 1的服务可以依赖Angular 2的服务，Angular 2的服务也可以依赖Angular 1的服务
- Angular 1的控制器可以依赖Angular 2的服务，Angular 2的组件也可以依赖Angular 1的服务
- Angular 1的模板中可以放Angular 2的组件，Angular 2的模板中也可以放Angular 1的指令
- Angular 1的模板可以透传(transclude)到Angular 2的组件中，Angular 2的模板也可以投影(project)到Angular 1的指令中
- Angular 1的模板可以使用Angular 2的管道，Angular 2的模板也可以使用Angular 1的过滤器
- ...

当然，还是会有一些细节上的限制，开始升级前请完整的看一遍官方提供的升级指南。

### 第三方代码咋办

在迁移过程中最痛苦、最不确定的部分大概就是第三方代码了，比如各种第三方的指令与服务等。这个可以按照下列步骤进行尝试：

#### 看看还有用不

首先要看一下，这些代码到底还有用没。Angular 2中对绑定体系进行了大幅提升，用属性绑定和事件绑定代替了原有的六十多个内建指令。一些简单的第三方指令也在其中，比如用来设置某些DOM属性的，或者用来响应某些事件的，都可以直接用Angular 2中的绑定来代替。如果不用指令就能实现，当然是最好的。

#### 自己写

有些指令本身并不复杂，其实可以自己用Angular 2写一份，用Angular 2写的时候由于可以借用新框架的很多特性，所以工作量并不像Angular 1中那么大，完全可以在可控的时间内自己写完。

#### 等新版

有些指令本身确实太复杂，那就没别的办法了。只能继续Hybrid方式，把它留在Angular 1中，等到它的作者推出了新版再迁移过去。如果一个指令本身又复杂又让你不得不用，那么说明这个指令本身就已经比较火了，你应该不会等很久。实在等不及了，就向社区求助吧，如果大家觉得这是一个值得应对的挑战，总会有人接招的。

### 扶上马，送一程

在升级过程中，Angular 1的代码可以和Angular 2的代码嵌合在一起，并逐步被替换为Angular 2格式的。在程序代码迁移的同时，单元测试和端到端测试也需要做出相应的迁移与调整。就这样一次一步的前进，最终会完全移除混合体中的Angular 1部分，我们的升级工作也就接近完成了。

## 再见，Angular 1

当一切都尘埃落定，并且在线上成功运行了一段时间之后，就可以着手移除Angular 1了。所谓移除也只剩下一件工作：把`UpgradeAdapter`的`bootstrap`替换为Angular 2的`bootstrap`，两者虽然同名，但是调用形式不同，只要按照Angular 2的调用约定修改一下就可以了。这里并没有什么需要特别注意的。

## 导入Angular 2风格

我们虽然已经把整个应用移到了Angular 2中，但是可能还留有很多Angular 1的遗迹，需要逐步清理它。现在的重点是，我们得导入Angular 2的风格，从用Angular 2写的Angular 1程序，变成一个真正的Angular 2程序。

### 局部化服务

在从Angular 1到Angular 2迁移的过程中，所有的服务都会注册到Angular 2的根组件下。但实际上这样做是不好的，在可能的情况下，我们应该让一个服务的可见范围尽可能小一些。这样一来，对每个服务的改动，我们都很清楚并能有效控制它的影响范围。一个任何改动都可以被局部化的系统，其可维护性显然是更好的。

### 局部化样式

在Angular 1的程序中，并没有让组件的样式局部化的机制，每一个样式都可能有很大的影响范围，而Angular 2提供了一个强大的组件样式机制，它可以把样式的影响局限在所属组件中。如果你在Angular 1中用某种机制模拟实现过类似的机制，那么就可以迁移过来，移除你自己样式局部化的机制。如果没有，那么赶快把它用起来吧！它会显著改善你的代码结构。

## 八卦 - Angular 2事件回顾

正事儿讲完了，我们来扒一点儿八卦。最近一期的技术雷达曾一次性把Angular移入了“评估”组同时把React等新崛起的竞争技术移入了“采用”，让人大跌眼镜，到底发生了什么？且听我慢慢道来。

### 那年，那次，那份草率的宣言

当Angular 2最初立项的时候，官方曾经出了一份文档，回答了大家关心的问题，它都说了什么呢？大意如下：

- 没有Module了！
- 没有Controller了！
- 没有Scope了！
- 没有...

然后是：

- 不兼容IE11以下的版本！
- 不能把Angular 1的程序升级成Angular 2！
- 不会提供让Angular 1程序升级成Angular 2的方案！
- 不用JavaScript了！
- 不...

没有任何耐心而详细解释，没有任何道歉和承诺！然后，整个社区都炸锅了！人们开始认为Angular 1和Angular 2是截然不同的两个框架，Angular 1的粉丝们觉得自己被抛弃了。就像所有被抛弃的人一样，粉丝们的情绪发生了严重的反弹。只有我这样失恋过N次的人才保持着淡定，并在心中冷笑：哼，你一定会回来找我的！

客观来讲，当时开发组的很多决策都是正确而且有前瞻性的，但是Angular这个技术极客构成的组织忘记了还有“情绪”这东西。而“情绪”会毁掉很多“技术精英”的努力，并让另一些“技术精英”成为自己的敌人。

### 专业性与谨言慎行

这就引出了一个问题：什么是专业性？

专业性，首先意味着避免情绪化。我相信在Angular开发组最初给出这份“No清单”的时候，心中应该是怀着“终于摆脱Angular 1的束缚”的快意的。这种情绪化会让人失去冷静，造成不可预期的结果，并且让自己无法准确评估这次行动的后果。

专业性，还意味着耐心。对任何事情都不应该轻易下结论，对社区的反弹，应该好好想一想为什么，而不要置之不理，继续忙自己的“极客”事业。事实上，当时只要用通俗易懂的语言详细解释一下为什么会有这份“No清单”，社区也有很多明眼人，并非不能接受。不作出任何官方解释就意味着连Angular的铁粉都无法作出任何权威而且一致的辩护。

专业性，最终还是要靠实力来保障。虽然Angular闹出了这么大的公关危机，但是Angular本身的社区基础和影响力还在。最终解决这个问题还是要靠实力，如果最终做出了一个让社区惊艳的产品，那么最终铁粉们还是会继续铁，而流失的粉丝也会再回来。

如果说Angular开发组应该从这次事件中吸取一个教训，简单来说，那就是“谨言慎行”。一个技术精英组织，如果未经详尽的调查就轻易给出情绪化的结论，最后被事实啪啪打脸，其信誉和影响力的损失将是非常显著的。

不过，最重要的是 ——

### 亡羊补牢，为时未晚

Angular开发组终于还是用行动弥补了自己的过失，最大的致歉礼物就是这个历时半年多锤炼出的`upgrade`模块，以及一份详尽的升级指南。另一项成果是他们在传统浏览器中模拟出了Shadow DOM的效果。后者在我看来曾是一件不可能的任务，不过只要大神一扎堆，果然是啥都能做出来。

## Angular开发组的诚意

Angular开发组仍然是一个极客组织，不过经过那件事之后，也开始反思，并变得更加重视社区建设与推广工作了。根据我得到的消息，Google为Angular项目组专门分配了推广预算，用于支持Angular的社区建设和技术推广。而中国，也是这次Angular的重点推广区域之一。我后面还会有一篇专门的文章《我是怎么“混进”Angular开发组的》，来好好讲讲这个小故事。敬请期待！